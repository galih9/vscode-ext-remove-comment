<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Fruit Game</title>
    <link rel="icon" href="/favicon.ico" />
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: linear-gradient(to bottom right, #000000, #1a1a1a);
        font-family: Arial, sans-serif;
      }
      #game-container {
        width: 400px;
        height: 600px;
        background-color: rgba(0, 0, 0, 0.8);
        border-radius: 0px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        position: relative;
      }
      #game-area {
        width: 100%;
        height: 550px;
        position: relative;
        overflow: hidden;
      }
      #next-fruit {
        position: absolute;
        top: 0;
        height: 50px;
        width: 50px;
        pointer-events: none;
      }
      .fruit {
        position: absolute;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }
      #score-display {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 24px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <div id="score-display">Score: 0</div>
      <div id="game-area">
        <div id="next-fruit"></div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>

    <script>
      const gameArea = document.getElementById("game-area");
      const nextFruitDisplay = document.getElementById("next-fruit");
      const scoreDisplay = document.getElementById("score-display");
      let nextFruit;
      let score = 0;
      let canDrop = true;
      const DROP_DELAY = 100;

      const Engine = Matter.Engine,
        Render = Matter.Render,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Events = Matter.Events,
        Composite = Matter.Composite;

      const engine = Engine.create();
      const render = Render.create({
        element: gameArea,
        engine: engine,
        options: {
          width: 400,
          height: 550,
          wireframes: false,
          background: "transparent",
        },
      });

      const ground = Bodies.rectangle(200, 575, 400, 50, {
        isStatic: true,
        render: { strokeStyle: '#ffffff', lineWidth: 2, fillStyle: 'transparent' }
      });
      const leftWall = Bodies.rectangle(0, 275, 50, 550, {
        isStatic: true,
        render: { strokeStyle: '#ffffff', lineWidth: 2, fillStyle: 'transparent' }
      });
      const rightWall = Bodies.rectangle(400, 275, 50, 550, {
        isStatic: true,
        render: { strokeStyle: '#ffffff', lineWidth: 2, fillStyle: 'transparent' }
      });

      World.add(engine.world, [ground, leftWall, rightWall]);

      Engine.run(engine);
      Render.run(render);

      const fruitTypes = [
        { name: "A", radius: 15, color: "#ff0000", point: 25 },
        { name: "B", radius: 20, color: "#ff3366", point: 50 },
        { name: "C", radius: 25, color: "#9932cc", point: 100 },
        { name: "D", radius: 30, color: "#ffa500", point: 200 },
        { name: "E", radius: 35, color: "#ffff00", point: 350 },
        { name: "F", radius: 40, color: "#ff0000", point: 500 },
        { name: "G", radius: 45, color: "#90ee90", point: 800 },
        { name: "H", radius: 50, color: "#ffdab9", point: 1200 },
        { name: "I", radius: 55, color: "#98fb98", point: 2500 },
        { name: "J", radius: 60, color: "#ff6347", point: 5000 },
      ];

      function getRandomFruit() {
        return fruitTypes[Math.floor(Math.random() * 5)];
      }

      function createFruit(x, y, fruit) {
        const circle = Bodies.circle(x, y, fruit.radius, {
          restitution: 0.3,
          friction: 0.1,
          render: { fillStyle: fruit.color },
          label: fruit.name
        });
        World.add(engine.world, circle);

        const fruitElement = document.createElement("div");
        fruitElement.className = "fruit";
        fruitElement.style.width = `${fruit.radius * 2}px`;
        fruitElement.style.height = `${fruit.radius * 2}px`;
        fruitElement.style.backgroundColor = fruit.color;
        fruitElement.textContent = fruit.name;
        gameArea.appendChild(fruitElement);

        return { body: circle, element: fruitElement, type: fruit };
      }

      function updateFruitPosition(fruit) {
        if (fruit.element && fruit.element.parentNode) {
            const { x, y } = fruit.body.position;
            fruit.element.style.left = `${x - fruit.body.circleRadius}px`;
            fruit.element.style.top = `${y - fruit.body.circleRadius}px`;
        }
      }

      function displayNextFruit() {
        nextFruit = getRandomFruit();
        nextFruitDisplay.innerHTML = `<div class="fruit" style="
          width: ${nextFruit.radius * 2}px;
          height: ${nextFruit.radius * 2}px;
          background-color: ${nextFruit.color};
          margin: auto;
        ">${nextFruit.name}</div>`;
      }

      let currentFruit = null;
      let fruits = [];

      function dropFruit(x) {
        if (!canDrop || currentFruit) return;

        canDrop = false;
        currentFruit = createFruit(x, nextFruit.radius + 30, nextFruit);
        fruits.push(currentFruit);
        displayNextFruit();
      }

      gameArea.addEventListener("mousemove", (e) => {
        if (!currentFruit && canDrop) {
          const rect = gameArea.getBoundingClientRect();
          const x = e.clientX - rect.left;
          nextFruitDisplay.style.left = `${x - nextFruit.radius}px`;
        }
      });

      gameArea.addEventListener("click", (e) => {
        const rect = gameArea.getBoundingClientRect();
        const x = e.clientX - rect.left;
        dropFruit(x);
      });

      Events.on(engine, 'collisionStart', function(event) {
          const pairs = event.pairs;

          pairs.forEach(function(pair) {
              const bodyA = pair.bodyA;
              const bodyB = pair.bodyB;

              const fruitA = fruits.find(f => f.body === bodyA);
              const fruitB = fruits.find(f => f.body === bodyB);

              if (fruitA && fruitB && fruitA.type.name === fruitB.type.name) {
                  const nextSizeIndex = fruitTypes.findIndex((f) => f.radius === fruitA.type.radius) + 1;
                  if (nextSizeIndex < fruitTypes.length) {
                      const newFruitType = fruitTypes[nextSizeIndex];
                      const newFruit = createFruit(
                          (bodyA.position.x + bodyB.position.x) / 2,
                          (bodyA.position.y + bodyB.position.y) / 2,
                          newFruitType
                      );
                      fruits.push(newFruit);

                      score += newFruitType.point;
                      scoreDisplay.textContent = `Score: ${score}`;

                      if (fruitA.element && fruitA.element.parentNode) gameArea.removeChild(fruitA.element);
                      if (fruitB.element && fruitB.element.parentNode) gameArea.removeChild(fruitB.element);

                      World.remove(engine.world, bodyA);
                      World.remove(engine.world, bodyB);

                      // NEW: If the current fruit was part of this merge, clear it
                      if (currentFruit && (currentFruit === fruitA || currentFruit === fruitB)) {
                          currentFruit = null;
                      }

                      fruits = fruits.filter((f) => f !== fruitA && f !== fruitB);
                  }
              }
          });
      });

      function gameLoop() {
        fruits = fruits.filter(fruit => Composite.allBodies(engine.world).includes(fruit.body));

        fruits.forEach(updateFruitPosition);

        // Logic to allow next fruit drop
        if (currentFruit && Math.abs(currentFruit.body.velocity.y) < 0.2 && currentFruit.body.position.y > (nextFruit.radius + 30 + 10)) {
            // Only set timeout if dropping is currently disabled, and the current fruit has settled
            if (!canDrop) {
                setTimeout(() => {
                    canDrop = true;
                    currentFruit = null; // Clear currentFruit here
                }, DROP_DELAY);
            }
        } else if (!currentFruit && !canDrop) {
            // This case handles situations where a fruit might have merged immediately
            // (currentFruit becomes null via collisionStart) or was never set.
            // Ensure canDrop becomes true after the delay.
            setTimeout(() => {
                canDrop = true;
            }, DROP_DELAY);
        }
        // No else if (!currentFruit && canDrop) is needed, as it's already in a state to drop.

        requestAnimationFrame(gameLoop);
      }

      displayNextFruit();
      gameLoop();
    </script>
  </body>
</html>